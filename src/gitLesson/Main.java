package gitLesson;

public class Main {
    public static void main(String[] args) {
        /* Set - реализация коллекции, в которой не важен индекс, но не допускаются повторы
        HashSet - реализация Seta, самая быстрая, хранит внутри себя мапу
        LinkedHashSet - сохраняет порядок добавления в отличие от HashSet, но медленнее
        TreeSet - содержит внутри себя дерево, позволяет легко сортировать элементы, например строки по алфавиту
        Map - содержит внутри себя ключ и значение, можно представить как некий словарь
        HashMap - самый быстрый
        LinkedHashMap - сохраняет порядок добавления
        TreeMap - позволяет сортировать элементы

        аннотации - "стикеры" для компилятора, которые позволяют сократить время и упростить жизнь себе и другим разработчикам,
        они не влияют напрямую на логику выполнения программы, но могут быть использованы компилятором, фреймворками или собственными скриптами для генерации кода, валидации, автоматизации конфигурации.
        для создания аннотации используется специальный класс синтаксис:
        @Target(ElementType.(значение - будет показывать то, к чему применяется аннотация))
        @Retention(RetentionPolicy.Runtime) - используется в 99% случаев, показывает когда аннотация активна
        public @interface (name){

        }
        Generics - позволяют параметризировать какие то классы(например List) и с помощью этого задать рамки, обходя даункастинг

        List<Animal> listOfAnimals = new ArrayList<>();
        listOfAnimals.add(new Animal(1);
        listOfAnimals.add(new Animal(2);

        List<Dog> listOfDogs = new ArrayList<>();
        listOfDogs.add(new Dog();
        listOfDogs.add(new Dog();

        test(listOfAnimals);
        test(listOfDogs);
        private static void test(List<? extends Animal> list) { - Wildcard - позволяет дать понять джаве, что мы можем подать на вход в лист не только объекты класса Animal, но и его наследников. super Animal - позволяет дать понять джаве, что мы подаем на вход объект класса выше по иерархии наследования
        for(Animal animal : list)
            System.out.println(animal);
        }

         */
    }
}
